/* Generated By:JavaCC: Do not edit this line. LRPRGParser.java */
import java.util.HashMap;
import br.ufpr.inf.heuchess.representacao.estrategia.ScenarioShape.PieceStatus;

public class LRPRGParser implements LRPRGParserConstants {

  public class TS {
     String Key;
     int Category;
     String Parameters = "";
         boolean NotAction = false;
  }

  public Pattern pattern;
  public HashMap<String, TS> ST = new HashMap();
  public String letfToken;
  public ScenarioShape scenario; /* elemento da tabela intermediária */

  public static final int _FIGURE = 0;
  public static final int _FUNCTION = 1;
  private PieceStatus figStatus;

  private boolean progMoves = false; // as pós condições só podem existir se os movimentos previstos/esperados 
                                        // no padrão forem especificados;

  private ScenarioShape.PieceOwner owner;
  private boolean ORClauseForm = false;

  public static void main(String args[]) throws ParseException
  {
    try
    {
       LRPRGParser parser = new LRPRGParser(System.in);
       parser.Patterns();
       System.out.println("Tudo certo! :)");
    }
    catch (ParseException e)
    {
      System.out.println("Erro de sintaxe: " + e.getMessage());
    }
  }

   // verifica se o pieceType passado na função movimentosde são do jogador que busca o padrão ou são do oponente
  public boolean myPiece(String pieceType)
  {
      return Character.isUpperCase(pieceType.charAt(0));
  }

/* IDENTIFIERS */

/** Root production. */
  final public void Patterns() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PATTERN:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      Pattern();
    }
    jj_consume_token(0);
  }

  final public void Pattern() throws ParseException {
 Token t;
 String s;
    jj_consume_token(PATTERN);
    t = jj_consume_token(TEXT);
                          pattern.setNome(t.image.substring(1, t.image.length()-1));
    jj_consume_token(AUTHOR);
    jj_consume_token(TEXT);
    jj_consume_token(DESCRIPTION);
    t = jj_consume_token(TEXT);
                              pattern.setDescription(t.image);
    jj_consume_token(WEIGHT);
    t = jj_consume_token(REAL);
                               pattern.setWeight(Double.parseDouble(t.image));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ACTORS:
      jj_consume_token(ACTORS);
      Atores();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PIECESET:
      jj_consume_token(PIECESET);
      ExclusiveSet();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    if (jj_2_1(2)) {
      jj_consume_token(FORMAT);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SCENARIO:
        jj_consume_token(SCENARIO);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    ScenarioShapePattern();
      StringBuilder sb = new StringBuilder();
      for(ScenarioShape f:pattern.getScenarioMembers()) {
         f.rightFigSource.addAll(f.rightFig);
         sb.append(f.toString()).append("\u005cn");
      }
      pattern.setScenario(sb.toString());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRECONDITION:
      jj_consume_token(PRECONDITION);
      s = LogicExpression();
                                          pattern.setPreConditionToJava(s);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MOVES:
      jj_consume_token(MOVES);
      Moves();
                      progMoves = true;
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case POSTCONDITION:
      jj_consume_token(POSTCONDITION);
      s = LogicExpression();
        if(!progMoves) {
           {if (true) throw new ParseException("P\u00f3s-condi\u00e7\u00f5es exigem sequ\u00eancia de movimentos previstos/esperados.");}
        }
        pattern.setPosConditionToJava(s);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(96);
  }

  final public void Relation() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_ATTACK:
      jj_consume_token(OP_ATTACK);
                 scenario.relationType = PatternRelationType.ATTACKS;
      break;
    case OP_DEFENSE:
      jj_consume_token(OP_DEFENSE);
                  scenario.relationType = PatternRelationType.DEFENDS;
      break;
    case OP_IATTACK:
      jj_consume_token(OP_IATTACK);
                  scenario.relationType = PatternRelationType.INDIRECTATTACK;
      break;
    case OP_IDEFENSE:
      jj_consume_token(OP_IDEFENSE);
                   scenario.relationType = PatternRelationType.INDIRECTDEFENSE;
      break;
    case OP_MOVE:
      jj_consume_token(OP_MOVE);
               scenario.relationType = PatternRelationType.MOVE;
      break;
    case OP_BLOCK:
      jj_consume_token(OP_BLOCK);
                scenario.relationType = PatternRelationType.BLOCKS;
      break;
    case OP_TOPSIDE:
      jj_consume_token(OP_TOPSIDE);
                  scenario.relationType = PatternRelationType.UPPERSIDE;
      break;
    case OP_RIGHTSIDE:
      jj_consume_token(OP_RIGHTSIDE);
                    scenario.relationType = PatternRelationType.RIGHTSIDE;
      break;
    case OP_LEFTSIDE:
      jj_consume_token(OP_LEFTSIDE);
                   scenario.relationType = PatternRelationType.LEFTSIDE;
      break;
    case OP_BOTTOMSIDE:
      jj_consume_token(OP_BOTTOMSIDE);
                     scenario.relationType = PatternRelationType.UNDERSIDE;
      break;
    case OP_SE:
      jj_consume_token(OP_SE);
             scenario.relationType = PatternRelationType.SE;
      break;
    case OP_NW:
      jj_consume_token(OP_NW);
             scenario.relationType = PatternRelationType.NW;
      break;
    case OP_NE:
      jj_consume_token(OP_NE);
             scenario.relationType = PatternRelationType.NE;
      break;
    case OP_SW:
      jj_consume_token(OP_SW);
             scenario.relationType = PatternRelationType.SW;
      break;
    case OP_PATTACK:
      jj_consume_token(OP_PATTACK);
                  scenario.relationType = PatternRelationType.POSSIBLEATTACK;
      break;
    case OP_PDEFENSE:
      jj_consume_token(OP_PDEFENSE);
                   scenario.relationType = PatternRelationType.POSSIBLEDEFENSE;
      break;
    case OP_CHECKMATE:
      jj_consume_token(OP_CHECKMATE);
                    scenario.relationType = PatternRelationType.CHECKMATE;
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Atores() throws ParseException {
 String t;
    t = figura0();
      TS simb = ST.get(t);
      if(simb == null) {
         simb = new TS();
         simb.Key = t;
         simb.Category = _FIGURE;
         ST.put(simb.Key, simb);
      }
      scenario = new ScenarioShape();
      scenario.orIni = false;
      scenario.orFim = false;
      scenario.leftFig = t;
      scenario.leftStatus = figStatus;
      scenario.relationType = PatternRelationType.DECLARATION;
      if("FfSs".indexOf(t.substring(0,1)) >= 0) {
          {if (true) throw new ParseException("Coringas n\u00e3o devem ser declarados como atores");}
      }
      if(Character.isUpperCase(t.charAt(0)))
      {
         scenario.leftOwner = ScenarioShape.PieceOwner.MINE;
      } else if(Character.isLowerCase(t.charAt(0)))
      {
         scenario.leftOwner = ScenarioShape.PieceOwner.YOURS;
      }
      pattern.getScenarioMembers().add(scenario);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 97:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_2;
      }
      jj_consume_token(97);
      t = figura0();
          simb = ST.get(t);
          if(simb == null) {
             simb = new TS();
             simb.Key = t;
             simb.Category = _FIGURE;
             ST.put(simb.Key, simb);
          }
          scenario = new ScenarioShape();
          scenario.orIni = false;
          scenario.orFim = false;
          scenario.leftFig = t;
          scenario.leftStatus = figStatus;
          scenario.relationType = PatternRelationType.DECLARATION;
          if("FfSs".indexOf(t.substring(0,1)) >= 0) {
              {if (true) throw new ParseException("Coringas n\u00e3o devem ser declarados como atores");}
          }
          if(Character.isUpperCase(t.charAt(0)))
          {
             scenario.leftOwner = ScenarioShape.PieceOwner.MINE;
          } else if(Character.isLowerCase(t.charAt(0)))
          {
             scenario.leftOwner = ScenarioShape.PieceOwner.YOURS;
          }
          pattern.getScenarioMembers().add(scenario);
    }
  }

  final public void ScenarioDescription() throws ParseException {
 String t;
    t = Figure1();
      TS simb = ST.get(t);
      if(simb == null) {
         simb = new TS();
         simb.Key = t;
         simb.Category = _FIGURE;
         simb.Parameters = ORClauseForm?"OR":"";
         ST.put(simb.Key, simb);
      }
      scenario = new ScenarioShape();
      scenario.orIni = false;
      scenario.orFim = false;
      scenario.leftFig = t;
      scenario.leftStatus = figStatus;
      if(t.charAt(0) == 'S' || t.charAt(0) == 's')
      {
         {if (true) throw new ParseException("Refer\u00eancia coringa <" + t +"> n\u00e3o pode estar isolada ou ao lado esquerdo da rela\u00e7\u00e3o: \u005cn"
                                  + "Linha: " + token.beginLine);}
      } else if(Character.isUpperCase(t.charAt(0)))
      {
         scenario.leftOwner = ScenarioShape.PieceOwner.MINE;
      } else if(Character.isLowerCase(t.charAt(0)))
      {
         scenario.leftOwner = ScenarioShape.PieceOwner.YOURS;
      }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_ATTACK:
    case OP_IATTACK:
    case OP_DEFENSE:
    case OP_IDEFENSE:
    case OP_MOVE:
    case OP_BLOCK:
    case OP_RIGHTSIDE:
    case OP_LEFTSIDE:
    case OP_TOPSIDE:
    case OP_BOTTOMSIDE:
    case OP_SE:
    case OP_NW:
    case OP_NE:
    case OP_SW:
    case OP_PATTACK:
    case OP_PDEFENSE:
    case OP_CHECKMATE:
      Relation();
                 scenario.notRelation = false;
      break;
    case OP_NOT:
      jj_consume_token(OP_NOT);
      Relation();
                                                                       scenario.notRelation = true; simb.NotAction = true;
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    Figure2();
     pattern.getScenarioMembers().add(scenario);
  }

  final public void ScenarioShapePattern() throws ParseException {
 Token t;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KING:
      case QUEEN:
      case ROOK:
      case BISHOP:
      case KNIGHT:
      case PAWN:
      case WILDCARD:
      case 100:
      case 101:
        ScenarioDescription();
        break;
      case 98:
        jj_consume_token(98);
        ORClauseForm = true;
        label_4:
        while (true) {
          ScenarioDescription();
                               scenario.orIni = true;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case KING:
          case QUEEN:
          case ROOK:
          case BISHOP:
          case KNIGHT:
          case PAWN:
          case WILDCARD:
          case 100:
          case 101:
            ;
            break;
          default:
            jj_la1[10] = jj_gen;
            break label_4;
          }
        }
        jj_consume_token(99);
     scenario.orFim = true; ORClauseForm = false;
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KING:
      case QUEEN:
      case ROOK:
      case BISHOP:
      case KNIGHT:
      case PAWN:
      case WILDCARD:
      case 98:
      case 100:
      case 101:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_3;
      }
    }
  }

  final public String PieceType() throws ParseException {
 Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KING:
      t = jj_consume_token(KING);
                {if (true) return myPiece(t.image)?"K":"k";}
      break;
    case QUEEN:
      t = jj_consume_token(QUEEN);
                 {if (true) return myPiece(t.image)?"Q":"q";}
      break;
    case BISHOP:
      t = jj_consume_token(BISHOP);
                  {if (true) return myPiece(t.image)?"B":"b";}
      break;
    case KNIGHT:
      t = jj_consume_token(KNIGHT);
                  {if (true) return myPiece(t.image)?"N":"n";}
      break;
    case ROOK:
      t = jj_consume_token(ROOK);
                {if (true) return myPiece(t.image)?"R":"r";}
      break;
    case PAWN:
      t = jj_consume_token(PAWN);
                {if (true) return myPiece(t.image)?"P":"p";}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String Piece() throws ParseException {
 Token t;
 String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WILDCARD:
      t = jj_consume_token(WILDCARD);
                    {if (true) return t.image;}
      break;
    case KING:
    case QUEEN:
    case ROOK:
    case BISHOP:
    case KNIGHT:
    case PAWN:
      s = PieceType();
                                                          {if (true) return s;}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String figura0() throws ParseException {
  Token t1;
  String s;
    s = PieceType();
    t1 = jj_consume_token(UINT);
                                figStatus = PieceStatus.ANYONE; {if (true) return s + t1.image;}
    throw new Error("Missing return statement in function");
  }

  final public String Figure1() throws ParseException {
  Token t1;
  String s;
    if (jj_2_2(2)) {
      s = Piece();
      t1 = jj_consume_token(UINT);
                            figStatus = PieceStatus.ANYONE; {if (true) return s + t1.image;}
    } else if (jj_2_3(2)) {
      jj_consume_token(100);
      s = Piece();
      t1 = jj_consume_token(UINT);
      jj_consume_token(101);
                                    figStatus = PieceStatus.PROTECTED; {if (true) return s + t1.image;}
    } else if (jj_2_4(2)) {
      jj_consume_token(101);
      s = Piece();
      t1 = jj_consume_token(UINT);
      jj_consume_token(100);
                                    figStatus = PieceStatus.UNPROTECTED; {if (true) return s + t1.image;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Figure2() throws ParseException {
  Token t;
  String s;
  TS simb;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KING:
    case QUEEN:
    case ROOK:
    case BISHOP:
    case KNIGHT:
    case PAWN:
    case WILDCARD:
    case 100:
    case 101:
      //relaçoes diretas
         s = Figure1();
      if(s.charAt(0) == 'S' || s.charAt(0) == 's') {
        owner = ScenarioShape.PieceOwner.ANYONE;
      } else if(Character.isUpperCase(s.charAt(0)))
      {
        owner = ScenarioShape.PieceOwner.MINE;
      } else
      {
        owner = ScenarioShape.PieceOwner.YOURS;
      }
      if(scenario.relationType == PatternRelationType.ATTACKS && scenario.leftOwner==owner) {
         {if (true) throw new ParseException("Pe\u00e7as do mesmo jogador n\u00e3o podem atacar-se mutuamente." +
                                  "\u005cnLinha: " + token.beginLine);}
      } else if(scenario.relationType == PatternRelationType.ATTACKS && owner == ScenarioShape.PieceOwner.ANYONE) {
          {if (true) throw new ParseException("Uma pe\u00e7a n\u00e3o pode atacar uma casa coringa, somente defender." +
                                  "\u005cnLinha: " + token.beginLine);}
      } else if(scenario.relationType == PatternRelationType.DEFENDS && owner!=scenario.leftOwner && owner != ScenarioShape.PieceOwner.ANYONE) {
         {if (true) throw new ParseException("Pe\u00e7as de um jogador n\u00e3o podem defender pe\u00e7as do outro."
                                  + "\u005cnLinha: " + token.beginLine);}
      } else if(scenario.relationType != PatternRelationType.MOVE &&
                scenario.relationType != PatternRelationType.DEFENDS &&
                scenario.relationType != PatternRelationType.CHECKMATE &&
                owner==ScenarioShape.PieceOwner.ANYONE) {
         {if (true) throw new ParseException("Operador relacional inv\u00e1lido. Utilize o operador de movimento ou defesas direta."
                                  + "\u005cnLinha: " + token.beginLine);}
      } else if(!scenario.relationType.getDireta()) {
          {if (true) {if (true) throw new ParseException("Operador relacional inv\u00e1lido. Utilize operadores diretos."
                                  + "\u005cnLinha: " + token.beginLine);}}
      } else {
          boolean jaexiste = false;
           for(int ix = 0; ix < scenario.rightFig.size(); ix++) {
              if (s.equals(scenario.rightFig.get(ix))) {
                  jaexiste = true; break;
              }
          }
          if(s.equals(scenario.leftFig) || jaexiste) {
              {if (true) throw new ParseException("Uma figura n\u00e3o pode interagir com ela mesma!");}
          }
      }
      simb = ST.get(s);
      if(simb == null) {
         simb = new TS();
         simb.Key = s;
         simb.Category = _FIGURE;
         simb.Parameters = ORClauseForm?"OR":"";
         ST.put(simb.Key, simb);
      }
      scenario.rightFig.add(s);
      scenario.rightStatus.add(figStatus);
      //redefine o owner para operações de consulta
      if(Character.isUpperCase(s.charAt(0)))
      {
        owner = ScenarioShape.PieceOwner.MINE;
      } else
      {
        owner = ScenarioShape.PieceOwner.YOURS;
      }
      scenario.rightOwner.add(owner);
      break;
    case 102:
      jj_consume_token(102);
      s = Figure1();
      simb = ST.get(s);
      if(simb == null) {
         simb = new TS();
         simb.Key = s;
         simb.Category = _FIGURE;
         simb.Parameters = ORClauseForm?"OR":"";
         ST.put(simb.Key, simb);
      }
      scenario.rightFig.add(s);
      scenario.rightStatus.add(figStatus);
      if(Character.isUpperCase(s.charAt(0))) {
         owner = ScenarioShape.PieceOwner.MINE;
      } else {
         owner = ScenarioShape.PieceOwner.YOURS;
      }
      scenario.rightOwner.add(owner);
      label_5:
      while (true) {
        jj_consume_token(97);
        s = Figure1();
      simb = ST.get(s);
      if(simb == null) {
         simb = new TS();
         simb.Key = s;
         simb.Category = _FIGURE;
         simb.Parameters = ORClauseForm?"OR":"";
         ST.put(simb.Key, simb);
      }
      scenario.rightFig.add(s);
      scenario.rightStatus.add(figStatus);
      if(s.charAt(0) == 'S' || s.charAt(0) == 's') {
         owner = ScenarioShape.PieceOwner.ANYONE;
      } else
      if(Character.isUpperCase(s.charAt(0))) {
         owner = ScenarioShape.PieceOwner.MINE;
      } else {
         owner = ScenarioShape.PieceOwner.YOURS;
      }
      scenario.rightOwner.add(owner);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 97:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_5;
        }
      }
      if((scenario.relationType == PatternRelationType.INDIRECTATTACK ||
          scenario.relationType == PatternRelationType.POSSIBLEATTACK ||
          scenario.relationType == PatternRelationType.ATTACKS) &&
          (owner==scenario.leftOwner || owner == ScenarioShape.PieceOwner.ANYONE)) {
         {if (true) throw new ParseException("Pe\u00e7as do mesmo jogador n\u00e3o podem atacar-se mutuamente ou coringas S."
                                  + "\u005cnLinha: " + token.beginLine);}
      } else if((scenario.relationType == PatternRelationType.INDIRECTDEFENSE ||
                 scenario.relationType == PatternRelationType.POSSIBLEDEFENSE) &&
                 owner != scenario.leftOwner &&
                 owner != ScenarioShape.PieceOwner.ANYONE ) {
         {if (true) throw new ParseException("O owner da \u00faltima pe\u00e7a da lista deve ser o mesmo da pe\u00e7a \u00e0 esquerda ou a pe\u00e7a deve ser um coringa S."
                                  + "\u005cnLinha: " + token.beginLine);}
      }  else if(scenario.relationType.getDireta()) {
          {if (true) {if (true) throw new ParseException("Operador relacional inv\u00e1lido. Utilize operadores indiretos."
                                  + "\u005cnLinha: " + token.beginLine);}}
      }
      jj_consume_token(103);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Moves() throws ParseException {
 String arg1 = "", arg2 = "";
    label_6:
    while (true) {
      arg1 = Figure1();
          TS simb = ST.get(arg1);
          if(simb == null) {
             {if (true) throw new ParseException("A figura [" + arg1 + "] deve estar declarada no scenario/atores do padr\u00e3o.");}
          }
      jj_consume_token(97);
      arg2 = Figure1();
          simb = ST.get(arg2);
          if(simb == null) {
             {if (true) throw new ParseException("A figura [" + arg2 + "] deve estar declarada no scenario/atores do padr\u00e3o.");}
          }
          if(arg2.equals(arg1)) {
              {if (true) throw new ParseException("O destino do movimento deve ser diferente da origem");}
          }
          if(Character.toUpperCase(arg2.charAt(0)) != 'S')
            if((Character.isUpperCase(arg1.charAt(0)) &&
                Character.isUpperCase(arg2.charAt(0))) ||
               (Character.isLowerCase(arg1.charAt(0)) &&
               Character.isLowerCase(arg2.charAt(0)))) {
                  {if (true) throw new ParseException("Movimento sobre pe\u00e7a pr\u00f3pria \u00e9 inv\u00e1lido!");}
            }
          pattern.getMoves().add(arg1 + "," + arg2); //adiciona a tabela IL de movimentos

      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KING:
      case QUEEN:
      case ROOK:
      case BISHOP:
      case KNIGHT:
      case PAWN:
      case WILDCARD:
      case 100:
      case 101:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_6;
      }
    }
  }

  final public String LogicExpression() throws ParseException {
 String s1 = "",s2 = "",s3 = "";
    s1 = ANDExpression();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OP_OR:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_7;
      }
      jj_consume_token(OP_OR);
                                  s2 = " || ";
      s3 = ANDExpression();
                                                                       s1 += s2 + s3;
    }
    {if (true) return s1;}
    throw new Error("Missing return statement in function");
  }

  final public String ANDExpression() throws ParseException {
 String s = "", s1 = "",s2 = "",s3 = "";
    s1 = EqualExpression();
                            s = s1;  pattern.getPreConditions().add(s1);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OP_AND:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_8;
      }
      jj_consume_token(OP_AND);
                s2 = " && ";
      s3 = EqualExpression();
           pattern.getPreConditions().add(s3);
           s += s2 + s3;
    }
     {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String EqualExpression() throws ParseException {
 String s1 = "",s3 = "";
 Token s2 = null;
    s1 = RelationalExpression();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 104:
      case 105:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 104:
        s2 = jj_consume_token(104);
        break;
      case 105:
        s2 = jj_consume_token(105);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s3 = RelationalExpression();
                                s1 += s2.image=="="?"==" + s3:s2.image + s3;
    }
    {if (true) return s1;}
    throw new Error("Missing return statement in function");
  }

  final public String RelationalExpression() throws ParseException {
 String s1 = "",s3 = "";
 Token s2 = null;
    s1 = AddExpression();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 100:
      case 101:
      case 106:
      case 107:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 100:
        s2 = jj_consume_token(100);
        break;
      case 101:
        s2 = jj_consume_token(101);
        break;
      case 106:
        s2 = jj_consume_token(106);
        break;
      case 107:
        s2 = jj_consume_token(107);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s3 = AddExpression();
                              s1 += s2.image + s3;
    }
    {if (true) return s1;}
    throw new Error("Missing return statement in function");
  }

  final public String AddExpression() throws ParseException {
 String s1 = "", s3 = "";
 Token s2 = null;
    s1 = MulExpression();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 108:
      case 109:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 108:
        s2 = jj_consume_token(108);
        break;
      case 109:
        s2 = jj_consume_token(109);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s3 = MulExpression();
                                      s1 += s2.image + s3;
    }
     {if (true) return s1;}
    throw new Error("Missing return statement in function");
  }

  final public String MulExpression() throws ParseException {
 String s1 = "",s3 = "";
 Token s2 = null;
    s1 = UnaryExpression();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 110:
      case 111:
      case 112:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 110:
        s2 = jj_consume_token(110);
        break;
      case 111:
        s2 = jj_consume_token(111);
        break;
      case 112:
        s2 = jj_consume_token(112);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s3 = UnaryExpression();
                              s1 += s2.image + s3;
    }
    {if (true) return s1;}
    throw new Error("Missing return statement in function");
  }

  final public String UnaryExpression() throws ParseException {
  Token t1 = null;
  Token t = null;
  String s1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UINT:
    case REAL:
    case 108:
    case 109:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 108:
      case 109:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 108:
          t1 = jj_consume_token(108);
          break;
        case 109:
          t1 = jj_consume_token(109);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UINT:
        t = jj_consume_token(UINT);
        break;
      case REAL:
        t = jj_consume_token(REAL);
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    if(t1==null) {{if (true) return t.image;} } else { {if (true) return t1.image + t.image;} }
      break;
    case TRUE:
      t = jj_consume_token(TRUE);
     {if (true) return "true";}
      break;
    case FALSE:
      t = jj_consume_token(FALSE);
    {if (true) return "false";}
      break;
    case WHITE:
    case BLACK:
    case SQUARECOLOR:
    case ISINFILE:
    case INSINRANK:
    case FILE:
    case RANK:
    case VALUE:
    case ONEDGE:
    case ONCORNER:
    case TYPEOF:
    case SENTRY:
    case RAM:
    case MAXDISTANCE:
    case MINDISTANCE:
    case RANKDISTANCE:
    case FILEDISTANCE:
    case MANDISTANCE:
    case SQUARERULE:
    case SQUAREOWNER:
    case MYDEFENSES:
    case YOURDEFENSES:
    case DEFENSES:
    case MYDEFENSESVALUE:
    case YOURDEFENSESVALUE:
    case DEFENSESVALUE:
    case RELATIVEVALUEOF:
    case MYDIRDEFENSES:
    case YOURDIRDEFENSES:
    case DIRECTDEFENSES:
    case MYRELDEFENSESVALUE:
    case YOURRELDEFENSESVALUE:
    case RELDFENSESVALUE:
    case MYDIRDEFENSESVALUE:
    case YOURDIRDEFENSESVALUE:
    case DIRDEFENSESVALUE:
    case WEDGES:
    case PIECESDEFENDING:
    case MOVESOF:
    case SAFEMOVESOF:
    case KINGPATH:
    case CHECKPATTERN:
    case KINGOPPOSITION:
    case BLOCKEDPAWNS:
      s1 = BuiltInFunction();
    {if (true) return s1;}
      break;
    case 102:
      jj_consume_token(102);
      s1 = LogicExpression();
      jj_consume_token(103);
    {if (true) return "(" + s1 + ")";}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* Funcões prédefinidas */
  final public String BuiltInFunction() throws ParseException {
  String f = "", args = "";
  Token arg;
    if (jj_2_9(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITE:
        jj_consume_token(WHITE);
                             f = "analise.WHITEPIECES()";
        break;
      case BLACK:
        jj_consume_token(BLACK);
                              f = "analise.BLACKPIECES()";
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FILE:
      case RANK:
      case ONEDGE:
      case ONCORNER:
      case SENTRY:
      case RAM:
      case MYDEFENSES:
      case YOURDEFENSES:
      case MYDEFENSESVALUE:
      case YOURDEFENSESVALUE:
      case RELATIVEVALUEOF:
      case MYDIRDEFENSES:
      case YOURDIRDEFENSES:
      case MYRELDEFENSESVALUE:
      case YOURRELDEFENSESVALUE:
      case MYDIRDEFENSESVALUE:
      case YOURDIRDEFENSESVALUE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FILE:
          jj_consume_token(FILE);
                             f = "analise.FILEOF";
          break;
        case RANK:
          jj_consume_token(RANK);
                              f = "analise.RANKOF";
          break;
        case ONEDGE:
          jj_consume_token(ONEDGE);
                              f = "analise.ONEDGE";
          break;
        case ONCORNER:
          jj_consume_token(ONCORNER);
                                f = "analise.ONCORNER";
          break;
        case MYDEFENSES:
          jj_consume_token(MYDEFENSES);
                            f = "analise.MYDEFENSES";
          break;
        case YOURDEFENSES:
          jj_consume_token(YOURDEFENSES);
                                f = "analise.YOURDEFENSES";
          break;
        case MYDEFENSESVALUE:
          jj_consume_token(MYDEFENSESVALUE);
                            f = "analise.MYDEFENSESVALUE";
          break;
        case YOURDEFENSESVALUE:
          jj_consume_token(YOURDEFENSESVALUE);
                                f = "analise.YOURDEFENSESVALUE";
          break;
        case RELATIVEVALUEOF:
          jj_consume_token(RELATIVEVALUEOF);
                                 f = "analise.RELATIVEVALUEOF";
          break;
        case MYDIRDEFENSES:
          jj_consume_token(MYDIRDEFENSES);
                            f = "analise.MYDIRDEFENSES";
          break;
        case YOURDIRDEFENSES:
          jj_consume_token(YOURDIRDEFENSES);
                                f = "analise.YOURDIRDEFENSES";
          break;
        case MYRELDEFENSESVALUE:
          jj_consume_token(MYRELDEFENSESVALUE);
                            f = "analise.MYRELDEFENSESVALUE";
          break;
        case YOURRELDEFENSESVALUE:
          jj_consume_token(YOURRELDEFENSESVALUE);
                                f = "analise.YOURRELDEFENSESVALUE";
          break;
        case MYDIRDEFENSESVALUE:
          jj_consume_token(MYDIRDEFENSESVALUE);
                            f = "analise.MYDIRDEFENSESVALUE";
          break;
        case YOURDIRDEFENSESVALUE:
          jj_consume_token(YOURDIRDEFENSESVALUE);
                                f = "analise.YOURDIRDEFENSESVALUE";
          break;
        case SENTRY:
          jj_consume_token(SENTRY);
                            f = "analise.SENTRY";
          break;
        case RAM:
          jj_consume_token(RAM);
                               f = "analise.RAM";
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(102);
        args = Args();
        jj_consume_token(103);
    {if (true) return f + "(\u005c"" + args + "\u005c")";}
        break;
      case BLOCKEDPAWNS:
        jj_consume_token(BLOCKEDPAWNS);
        jj_consume_token(102);
        arg = jj_consume_token(OWNER);
        jj_consume_token(103);
      f = "analise.ISPAWNSBLOCKED(\u005c"" + arg.image + "\u005c")";
      {if (true) return f;}
        break;
      case SQUARECOLOR:
        jj_consume_token(SQUARECOLOR);
                                    f = "analise.SQUARECOLOROF";
        jj_consume_token(102);
        if (jj_2_5(2)) {
          args = Args();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case KING:
          case QUEEN:
          case ROOK:
          case BISHOP:
          case KNIGHT:
          case PAWN:
          case WILDCARD:
            args = Piece();
            break;
          default:
            jj_la1[34] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(103);
      {if (true) return f + "(\u005c"" + args + "\u005c")";}
        break;
      case VALUE:
        jj_consume_token(VALUE);
                               f = "analise.VALUEOF";
        jj_consume_token(102);
        if (jj_2_6(2)) {
          args = Args();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case KING:
          case QUEEN:
          case ROOK:
          case BISHOP:
          case KNIGHT:
          case PAWN:
            args = PieceType();
            break;
          default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(103);
      {if (true) return f + "(\u005c"" + args + "\u005c")";}
        break;
      case MOVESOF:
        jj_consume_token(MOVESOF);
                          f = "analise.MOVESOF";
        jj_consume_token(102);
        if (jj_2_7(2)) {
          args = Args();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case KING:
          case QUEEN:
          case ROOK:
          case BISHOP:
          case KNIGHT:
          case PAWN:
            args = PieceType();
            break;
          default:
            jj_la1[36] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(103);
      {if (true) return f + "(\u005c"" + args + "\u005c")";}
        break;
      case SAFEMOVESOF:
        jj_consume_token(SAFEMOVESOF);
                       f = "analise.SAFEMOVESOF";
        jj_consume_token(102);
        if (jj_2_8(2)) {
          args = Args();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case KING:
          case QUEEN:
          case ROOK:
          case BISHOP:
          case KNIGHT:
          case PAWN:
            args = PieceType();
            break;
          default:
            jj_la1[37] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(103);
      {if (true) return f + "(\u005c"" + args + "\u005c")";}
        break;
      case DEFENSES:
      case DEFENSESVALUE:
      case DIRECTDEFENSES:
      case RELDFENSESVALUE:
      case DIRDEFENSESVALUE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFENSES:
          jj_consume_token(DEFENSES);
                       f = "analise.DEFENSESOF";
          break;
        case DEFENSESVALUE:
          jj_consume_token(DEFENSESVALUE);
                            f = "analise.DEFENSESVALUEOF";
          break;
        case DIRECTDEFENSES:
          jj_consume_token(DIRECTDEFENSES);
                             f = "analise.DIRECTDEFENSESOF";
          break;
        case DIRDEFENSESVALUE:
          jj_consume_token(DIRDEFENSESVALUE);
                               f = "analise.DIRECTDEFENSESVALUEOF";
          break;
        case RELDFENSESVALUE:
          jj_consume_token(RELDFENSESVALUE);
                              f = "analise.RELDEFENSESVALUEOF";
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        args = OwnerArgs();
         {if (true) return f + args;}
        break;
      case SQUAREOWNER:
        jj_consume_token(SQUAREOWNER);
                        f = "analise.SQUAREOWNER";
        args = SquareOwnerArgs();
          {if (true) return f + args;}
        break;
      case TYPEOF:
      case PIECESDEFENDING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TYPEOF:
          jj_consume_token(TYPEOF);
                                 f = "analise.TYPEOF";
          break;
        case PIECESDEFENDING:
          jj_consume_token(PIECESDEFENDING);
                                     f = "analise.PIECESDEFENDING";
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        args = TypeArgs();
      {if (true) return f + args;}
        break;
      case ISINFILE:
        jj_consume_token(ISINFILE);
                         f = "analise.EXISTINFILE";
        args = FileExistArgs();
      {if (true) return f + args;}
        break;
      case INSINRANK:
        jj_consume_token(INSINRANK);
                           f = "analise.EXISTINRANK";
        args = RankExistArgs();
      {if (true) return f + args;}
        break;
      case MAXDISTANCE:
      case MINDISTANCE:
      case RANKDISTANCE:
      case FILEDISTANCE:
      case MANDISTANCE:
      case SQUARERULE:
      case WEDGES:
      case KINGPATH:
      case KINGOPPOSITION:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KINGPATH:
          jj_consume_token(KINGPATH);
                   f = "analise.KINGPATHTO";
          break;
        case KINGOPPOSITION:
          jj_consume_token(KINGOPPOSITION);
                          f = "analise.KINGOPPOSITION";
          break;
        case RANKDISTANCE:
          jj_consume_token(RANKDISTANCE);
                       f = "analise.RANKDISTANCE";
          break;
        case FILEDISTANCE:
          jj_consume_token(FILEDISTANCE);
                       f = "analise.FILEDISTANCE";
          break;
        case MANDISTANCE:
          jj_consume_token(MANDISTANCE);
                      f = "analise.MANHATTANDISTANCE";
          break;
        case MAXDISTANCE:
          jj_consume_token(MAXDISTANCE);
                      f = "analise.MAXDISTANCE";
          break;
        case MINDISTANCE:
          jj_consume_token(MINDISTANCE);
                      f = "analise.MINDISTANCE";
          break;
        case SQUARERULE:
          jj_consume_token(SQUARERULE);
                       f = "analise.INTHESQUARE";
          break;
        case WEDGES:
          jj_consume_token(WEDGES);
                           f = "analise.WEDGESBETWEEN";
          break;
        default:
          jj_la1[40] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        args = DistanceArgs();
      {if (true) return f + args;}
        break;
      case CHECKPATTERN:
        jj_consume_token(CHECKPATTERN);
        jj_consume_token(102);
        args = PatternArgs();
        jj_consume_token(103);
      f = "analise.EXISTPATTERN(\u005c"" + args + "\u005c")";
      {if (true) return f;}
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String ExclusiveSet() throws ParseException {
 String t = "", s = "";
    label_13:
    while (true) {
      s = PieceType();
                     pattern.getExclusiveSet().add(s.charAt(0)); t = t + s;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KING:
      case QUEEN:
      case ROOK:
      case BISHOP:
      case KNIGHT:
      case PAWN:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_13;
      }
    }
    if(pattern.getExclusiveSet().size() < 3) {
          {if (true) throw new ParseException("Tr\u00eas pe\u00e7as no m\u00ednimo devem compor o conjunto exclusivo.");}
    }
    {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public String PatternArgs() throws ParseException {
  Token t;
  Token d;
    t = jj_consume_token(TEXT);
    jj_consume_token(97);
    d = jj_consume_token(OWNER);
    pattern.setRecursiveSearch(d.image.startsWith("OP"));
    {if (true) return t.image.substring(1,t.image.length()-1) + "," + d.image;}
    throw new Error("Missing return statement in function");
  }

  final public String Args() throws ParseException {
  String s;
    s = Figure1();
      TS simb = ST.get(s);
      if(simb == null)
      {
         {if (true) throw new ParseException("A figura [" + s + "] deve estar declarada no scenario do padr\u00e3o.");}
      }
      {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public String OwnerArgs() throws ParseException {
 String arg1 = "", arg2 = "";
 Token t = null;
    jj_consume_token(102);
    arg1 = Figure1();
    jj_consume_token(97);
    t = jj_consume_token(OWNER);
                    arg2 = t.image;
    jj_consume_token(103);
     {if (true) return "(\u005c"" + arg1 + "," + arg2 + "\u005c")";}
    throw new Error("Missing return statement in function");
  }

  final public String SquareOwnerArgs() throws ParseException {
 String arg1 = "", arg2 = "";
 Token t = null;
    jj_consume_token(102);
    arg1 = Figure1();
    jj_consume_token(97);
    t = jj_consume_token(FULLOWNER);
                         arg2 = t.image;
    jj_consume_token(103);
     {if (true) return "(\u005c"" + arg1 + "," + arg2 + "\u005c")";}
    throw new Error("Missing return statement in function");
  }

  final public String FileExistArgs() throws ParseException {
 String arg1 = "", arg2 = "", arg3 = "";
 Token t = null;
    jj_consume_token(102);
    arg1 = Piece();
    jj_consume_token(97);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UINT:
      t = jj_consume_token(UINT);
          arg2 = t.image;
      break;
    case FILE:
      jj_consume_token(FILE);
      jj_consume_token(102);
      arg3 = Args();
      jj_consume_token(103);
          arg2 = "analise.COLUNADE(" + arg3 + ")";
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(103);
     {if (true) return "(\u005c"" + arg1 + "," + arg2 + "\u005c")";}
    throw new Error("Missing return statement in function");
  }

  final public String RankExistArgs() throws ParseException {
 String arg1 = "", arg2 = "", arg3 = "";
 Token t = null;
    jj_consume_token(102);
    arg1 = Piece();
    jj_consume_token(97);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UINT:
      t = jj_consume_token(UINT);
          arg2 = t.image;
      break;
    case RANK:
      jj_consume_token(RANK);
      jj_consume_token(102);
      arg3 = Args();
      jj_consume_token(103);
          arg2 = "analise.COLUNADE(" + arg3 + ")";
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(103);
    {if (true) return "(\u005c"" + arg1 + "," + arg2 + "\u005c")";}
    throw new Error("Missing return statement in function");
  }

  final public String TypeArgs() throws ParseException {
 String arg1 = "", arg2 = "";
    jj_consume_token(102);
    arg1 = Figure1();
      TS simb = ST.get(arg1);
      if(simb == null) {
         {if (true) throw new ParseException("A figura [" + arg1 + "] deve estar declarada no scenario do padr\u00e3o.");}
      }
    jj_consume_token(97);
    arg2 = PieceType();
      simb = ST.get(arg2);
      if(simb == null) {
         simb = new TS();
         simb.Key = arg2;
         simb.Category = _FUNCTION;
         ST.put(simb.Key, simb);
      }
    jj_consume_token(103);
    {if (true) return "(\u005c"" + arg1 + "," + arg2 + "\u005c")";}
    throw new Error("Missing return statement in function");
  }

  final public String DistanceArgs() throws ParseException {
 String arg1 = "", arg2 = "";
    jj_consume_token(102);
    arg1 = Figure1();
      TS simb = ST.get(arg1);
      if(simb == null) {
         {if (true) throw new ParseException("A figura [" + arg1 + "] deve estar declarada no scenario do padr\u00e3o.");}
      }
    jj_consume_token(97);
    arg2 = Figure1();
      simb = ST.get(arg2);
      if(simb == null) {
         {if (true) throw new ParseException("A figura [" + arg2 + "] deve estar declarada no scenario do padr\u00e3o.");}
      }
    jj_consume_token(103);
    {if (true) return "(\u005c"" + arg1 + "," + arg2 + "\u005c")";}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_3_1() {
    if (jj_scan_token(FORMAT)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(100)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_14()) return true;
    if (jj_scan_token(UINT)) return true;
    return false;
  }

  private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3_4()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(BLACK)) return true;
    return false;
  }

  private boolean jj_3R_16() {
    if (jj_scan_token(WHITE)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_scan_token(WILDCARD)) return true;
    return false;
  }

  private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_16()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) return true;
    }
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_scan_token(PAWN)) return true;
    return false;
  }

  private boolean jj_3R_26() {
    if (jj_scan_token(ROOK)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_scan_token(KNIGHT)) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_scan_token(BISHOP)) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_scan_token(QUEEN)) return true;
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_scan_token(KING)) return true;
    return false;
  }

  private boolean jj_3R_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(101)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public LRPRGParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[45];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x20,0x100,0x200,0x800,0x2000,0x1000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff0000,0x30000,0x1b600000,0x0,0x0,0x0,0x0,0x0,0x4000000,0xe0000000,0xfffc0000,0x0,0x200000,0x400000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000000,0xf0000000,0xf0000000,0xf0000000,0xf0000000,0x0,0xf0000000,0xf0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffffff,0x0,0x6ddb0,0xf0000000,0xf0000000,0xf0000000,0xf0000000,0x92240,0x200000,0x5100007,0xfffffff,0xf0000000,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fffc00,0x0,0xffffc00,0x13,0x13,0x13,0x3,0x13,0x0,0x13,0x13,0x40,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x60000180,0x0,0x0,0x13,0x3,0x3,0x3,0x0,0x0,0x0,0x0,0x3,0x20000000,0x20000000,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x30,0x34,0x34,0x0,0x0,0x2,0x70,0x30,0x0,0x0,0x300,0x300,0xc30,0xc30,0x3000,0x3000,0x1c000,0x1c000,0x3000,0x3000,0x0,0x3040,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public LRPRGParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public LRPRGParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new LRPRGParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public LRPRGParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new LRPRGParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public LRPRGParser(LRPRGParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(LRPRGParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[113];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 45; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 113; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
